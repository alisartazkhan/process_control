
#include <usloss.h>
#include <stdio.h>
#include <phase1.h>
#include <phase2.h>
#include <phase3.h>
#include <stdlib.h>
#include <assert.h>

int CLOCK_DAEMON_MBOX_ID = -2000;
int TERM0_DAEMON_MBOX_ID = -2001;
int TERM1_DAEMON_MBOX_ID = -2002;
int TERM2_DAEMON_MBOX_ID = -2003;
int TERM3_DAEMON_MBOX_ID = -2004;
int DISK0_DAEMON_MBOX_ID = -2005;
int DISK1_DAEMON_MBOX_ID = -2006;

int GLOBAL_CLOCK_TICK = 0;

typedef struct PCB_Clock PCB_Clock;
struct PCB_Clock {
    int occupied;
	int pid;
    int wakeTime;
    int mboxID;
    PCB_Clock* next;
};
PCB_Clock PROC_table_clock[MAXPROC];
PCB_Clock * CLOCK_WAITQUEUE_HEAD;

typedef struct PCB_Term PCB_Term; 
struct PCB_Term {
    int occupied;
	int pid;
    char buff[MAXLINE+1];
    int mboxID;
    PCB_Term * next;
};
PCB_Term PROC_table_term[MAXPROC];
PCB_Term * TERM0_READ_QUEUE_HEAD;
PCB_Term * TERM0_WRITE_QUEUE_HEAD;

void createPCB_Clock(int idx, int pid, int wakeTime, int mboxID) {
    PROC_table_clock[idx].occupied = 1;
    PROC_table_clock[idx].pid = pid;
    PROC_table_clock[idx].wakeTime = wakeTime;
    PROC_table_clock[idx].mboxID = mboxID;
    PROC_table_clock[idx].next = NULL;
}

void destroyPCB_Clock(int idx) {
    PROC_table_clock[idx].occupied = 0;
    PROC_table_clock[idx].pid = -1;
    PROC_table_clock[idx].wakeTime = -1;
    PROC_table_clock[idx].mboxID = -1;
    PROC_table_clock[idx].next = NULL;
}

void createPCB_Term(int idx, int pid, int mboxID) {
    PROC_table_term[idx].occupied = 1;
    PROC_table_term[idx].pid = pid;
    PROC_table_term[idx].mboxID = mboxID;
    PROC_table_term[idx].next = NULL;
    memset(PROC_table_term[idx].buff, NULL, MAXLINE+1);
}

void destroyPCB_Term(int idx) {
    PROC_table_term[idx].occupied = 0;
    PROC_table_term[idx].pid = -1;
    PROC_table_term[idx].mboxID = -1;
    PROC_table_term[idx].next = NULL;
    memset(PROC_table_term[idx].buff, NULL, MAXLINE+1);
}

void printPCB_ClockList(PCB_Clock* head) {
    PCB_Clock* current = head;
    USLOSS_Console("*************************\n\n");
    USLOSS_Console("PCB_Clock Linked List:\n");
    int counter = 0;


    while (current != NULL) {
        USLOSS_Console("PCB_Clock # %d\n", counter);

        USLOSS_Console("Occupied: %d\n", current->occupied);
        USLOSS_Console("PID: %d\n", current->pid);
        USLOSS_Console("WakeTime: %d\n", current->wakeTime);
        USLOSS_Console("MboxID: %d\n", current->mboxID);
        USLOSS_Console("\n");

        counter += 1;

        if (counter >= 3) {
            break;
        } 

        current = current->next;
    }
    USLOSS_Console("*************************\n\n");
}

void insertClockWaitQueue(PCB_Clock* new_node) {
    // USLOSS_Console("LINE %d\n",__LINE__);

    // Placing at head
    if (CLOCK_WAITQUEUE_HEAD == NULL || 
        new_node->wakeTime <= CLOCK_WAITQUEUE_HEAD->wakeTime) {

        // USLOSS_Console("LINE %d\n",__LINE__);
        // USLOSS_Console("BEFORE INSERT AT HEAD\n");
        // printPCB_ClockList(CLOCK_WAITQUEUE_HEAD);

        new_node->next = CLOCK_WAITQUEUE_HEAD;
        CLOCK_WAITQUEUE_HEAD = new_node;

        // USLOSS_Console("AFTER INSERT AT HEAD\n");
        // printPCB_ClockList(CLOCK_WAITQUEUE_HEAD);
        // USLOSS_Console("LINE %d\n",__LINE__);

    } else {
        // Placing in the middle or end
        PCB_Clock* current = CLOCK_WAITQUEUE_HEAD;
        while (current->next != NULL && current->next->wakeTime <= new_node->wakeTime) {
            
            // USLOSS_Console("LINE %d\n",__LINE__);
            current = current->next;
        }
        // USLOSS_Console("LINE %d\n",__LINE__);
        // USLOSS_Console("BEFORE INSERT AT END\n");
        // printPCB_ClockList(CLOCK_WAITQUEUE_HEAD);

        new_node->next = current->next;
        current->next = new_node;

        // USLOSS_Console("AFTER INSERT AT END\n");
        // printPCB_ClockList(CLOCK_WAITQUEUE_HEAD);
        // USLOSS_Console("LINE %d\n",__LINE__);
    }
}

void insertTermWaitQueue(PCB_Term* new_node, int unitNo, int isReadQueue) {
    // USLOSS_Console("LINE %d\n",__LINE__);

    // place at tail
    switch(unitNo) {
        case 0: 
            if (isReadQueue) {
                PCB_Term * curr = TERM0_READ_QUEUE_HEAD;
                while (curr->next != NULL) {
                    curr = curr->next;
                }
                curr->next = new_node;
            } else {
                PCB_Term * curr = TERM0_WRITE_QUEUE_HEAD;
                while (curr->next != NULL) {
                    curr = curr->next;
                }
                curr->next = new_node;
            }
        // TODO same for 1,2,3
    }
}

void wakeAndRemoveClockWaitQueue() {
    // USLOSS_Console("LINE %d\n",__LINE__);

    // remove head elements that need to be woken up
    while (CLOCK_WAITQUEUE_HEAD != NULL && GLOBAL_CLOCK_TICK * 100 >= CLOCK_WAITQUEUE_HEAD->wakeTime) {
        // USLOSS_Console("LINE %d\n",__LINE__);

        int mboxID = CLOCK_WAITQUEUE_HEAD->mboxID;
        MboxSend(mboxID, NULL, 0);

        // USLOSS_Console("LINE %d\n",__LINE__);

        MboxRelease(CLOCK_WAITQUEUE_HEAD->mboxID);
        
        PCB_Clock * prev = CLOCK_WAITQUEUE_HEAD;

        // USLOSS_Console("BEFORE REMOVE\n");
        // printPCB_ClockList(CLOCK_WAITQUEUE_HEAD);

        CLOCK_WAITQUEUE_HEAD = CLOCK_WAITQUEUE_HEAD->next;

        int idx = _getIdx_of_pid_Clock(prev->pid);
        destroyPCB_Clock(idx);

        // USLOSS_Console("AFTER REMOVE\n");
        // printPCB_ClockList(CLOCK_WAITQUEUE_HEAD);

        // USLOSS_Console("LINE %d\n",__LINE__);   
    }
}

void wakeAndRemomveTermWaitQueue(int unitNo, int readQueue) {
    if (unitNo == 0 && readQueue == 1) {
        int mboxID = TERM0_READ_QUEUE_HEAD->mboxID;
        MboxSend(mboxID, NULL, 0);

        // USLOSS_Console("LINE %d\n",__LINE__);

        MboxRelease(TERM0_READ_QUEUE_HEAD->mboxID);
        
        PCB_Clock * prev = TERM0_READ_QUEUE_HEAD;

        // USLOSS_Console("BEFORE REMOVE\n");
        // printPCB_ClockList(CLOCK_WAITQUEUE_HEAD);

        TERM0_READ_QUEUE_HEAD = TERM0_READ_QUEUE_HEAD->next;

        int idx = _getIdx_of_pid_Term(prev->pid);
        destroyPCB_Term(idx);

        // USLOSS_Console("AFTER REMOVE\n");
        // printPCB_ClockList(CLOCK_WAITQUEUE_HEAD);

        // USLOSS_Console("LINE %d\n",__LINE__);   
    }
    
}

int _getIdxPROCTable_Clock(int pid) {
	int idx = pid % MAXPROC;
	int numChecksSoFar = 0;

	while (PROC_table_clock[idx].occupied)
	{
		if (numChecksSoFar > MAXPROC)
		{
			return -1;
		}
		numChecksSoFar += 1;
		idx = pid % MAXPROC;
	}
	return idx;
}

int _getIdx_of_pid_Clock(int pid) {
	int idx = pid % MAXPROC;
	int numChecksSoFar = 0;

	while (PROC_table_clock[idx].pid != pid)
	{
		if (numChecksSoFar > MAXPROC)
		{
			// Process not found on proc table, 
			// (maybe an already cleaned up proc or nonexistant), shouldnt be possible
			return -1;
		}
		idx += 1;
		numChecksSoFar += 1;
		idx = idx % MAXPROC;
	}
	return idx;
}

int _getIdxPROCTable_Term(int pid) {
	int idx = pid % MAXPROC;
	int numChecksSoFar = 0;

	while (PROC_table_term[idx].occupied)
	{
		if (numChecksSoFar > MAXPROC)
		{
			return -1;
		}
		numChecksSoFar += 1;
		idx = pid % MAXPROC;
	}
	return idx;
}

int _getIdx_of_pid_Term(int pid) {
	int idx = pid % MAXPROC;
	int numChecksSoFar = 0;

	while (PROC_table_term[idx].pid != pid)
	{
		if (numChecksSoFar > MAXPROC)
		{
			// Process not found on proc table, 
			// (maybe an already cleaned up proc or nonexistant), shouldnt be possible
			return -1;
		}
		idx += 1;
		numChecksSoFar += 1;
		idx = idx % MAXPROC;
	}
	return idx;
}

int clock_daemon_main(char *args) {
    // USLOSS_Console("IN CLOCK DAEMON\n");

    int clock_dev_status = -1;

    while(1) {
        waitDevice(USLOSS_CLOCK_DEV, 0, &clock_dev_status);



        // NOTE: when we are at this line, we're unblocked by clock device
        // unblocked at every ~100ms, which is each tick

        GLOBAL_CLOCK_TICK += 1;

        // USLOSS_Console("Tick %d\tstatus = %d\n", GLOBAL_CLOCK_TICK, clock_dev_status);
        wakeAndRemoveClockWaitQueue();
    }
    return 0;
}

/*
    int unit = ... ; // which terminal to write to
    char *buf = ... ; // a string in memory, somewhere
    int i = ... ; // the index, into the string, of the next char to send

    int cr_val = 0x1; // this turns on the ’send char’ bit (USLOSS spec page 9)
    cr_val |= 0x2; // recv int enable
    cr_val |= 0x4; // xmit int enable
    cr_val |= (buf[i] << 8); // the character to send
    
    USLOSS_DeviceOutput(USLOSS_TERM_DEV, unit, (void*)(long)cr_val);
*/
void handle_one_terminal_interrupt(int unit, int status) {

    // pull bit pairs out
    int recvStatus = status & 0b11;
    int xmitStatus = status & 0b1100 >> 2;

    if (recvStatus == USLOSS_DEV_BUSY)  {
        // read character from status
        char charRead = status & 0b1111111100000000 >> 8;
        USLOSS_Console("Read from term  = %c\n",charRead);

        // place character in buffer

        // wake up waiting process (if appropriate)
    }
    // if (xmitStatus == USLOSS_DEV_READY) {
    //     if ( ... a previous send has now completed a "write" op ... )
    //          ... wake up a waiting process ...
    //     if ( ... some buffer is waiting to be flushed ... )
    //          ... send a single character ...
    // }
}

int term0_daemon_main(char *args) {
    // USLOSS_Console("IN CLOCK DAEMON\n");

    int term0_dev_status = -1;

    while(1) {
        waitDevice(USLOSS_TERM_DEV, 0, &term0_dev_status);

        handle_one_terminal_interrupt(0, term0_dev_status);
    }
    return 0;
}

int dummy_main(char *args) {
    return 0;
}

/*
System Call Arguments:
     arg1: buffer pointer
     arg2: length of the buffer
     arg3: which terminal to read
System Call Outputs:
     arg2: number of characters read
     arg4: -1 if illegal values were given as input; 0 otherwise
*/
int kernTermReadWrapper(USLOSS_Sysargs * args) {
    char * destBufPtr = args->arg1;
    int destBufLen = args->arg2;
    int termUnitId = args->arg3;

    int lenActuallyRead = -1;

    int retVal = kernTermRead(destBufPtr, destBufLen,termUnitId, &lenActuallyRead);

    args->arg2 = lenActuallyRead;
    args->arg4 = retVal;
}

int  kernTermRead (char *buffer, int bufferSize, int unitID,
                            int *numCharsRead) {
    /* TODO error check: 
        termID 
        negative length
        zero chars being requested to be read
    return -1
    */

    // set buffer to MAXLINE + 1 for \0
    memset(buffer, NULL, sizeof(buffer));

    int pid = getpid();
    int idx = _getIdxPROCTable_Term(pid);
    int mboxId = MboxCreate(1,0);

    createPCB_Term(idx, pid, mboxId);
    PCB_Term * newPCB_Term = &PROC_table_term[idx];

    // USLOSS_Console("LINE %d\n",__LINE__);

    // grab a lock to term unit
    int sendVRetVal = MboxSend(TERM0_DAEMON_MBOX_ID, NULL, 0);

    insertTermWaitQueue(newPCB_Term, unitID, 1);

    int recvRetVal = MboxRecv(TERM0_DAEMON_MBOX_ID, NULL, 0);

    // block this process so it goes to sleep
    int recVretVal = MboxRecv(mboxId, NULL, 0);
    
    return 0;
}

void phase4_start_service_processes(void) {
    int clockDaemonPID = fork1("clock_daemon", clock_daemon_main, NULL, 
        USLOSS_MIN_STACK, 1);
    // int term0DaemonPID = fork1("term0_daemon", term0_daemon_main, NULL, 
    //     USLOSS_MIN_STACK, 1);
    // int term1DaemonPID = fork1("term1_daemon", dummy_main, NULL, 
    //     USLOSS_MIN_STACK, 1);
    // int term2DaemonPID = fork1("term2_daemon", dummy_main, NULL, 
    //     USLOSS_MIN_STACK, 1);
    // int term3DaemonPID = fork1("term3_daemon", dummy_main, NULL, 
    //     USLOSS_MIN_STACK, 1);
    // int disk0DaemonPID = fork1("disk0_daemon", dummy_main, NULL, 
    //     USLOSS_MIN_STACK, 1);
    // int disk1DaemonPID = fork1("disk1_daemon", dummy_main, NULL, 
    //     USLOSS_MIN_STACK, 1);
}

/*
1) callers add themselves to the clockdaemon queue

    i) populate shadow pcb with:
        a) pid
        b) waketime = arrival + sleep duration
        c) mbox id
    ii) puts itself on clockdaemon queue with ref to its shadow pcb

2) recv() from that mbox
3) clean up (mboxdestroy the mbox)    
*/

/*
 * kernel mode interfaces to the same mechanisms as the syscalls
 */
int  kernSleep(int seconds) {
    // TODO: error checking return -1

    int pid = getpid();
    int idx = _getIdxPROCTable_Clock(pid);
    int arrivalTime_ms = GLOBAL_CLOCK_TICK * 100;      // TICK to  ms
    int sleepDuration_ms = seconds * 1000;             // s    to  ms
    int wakeTime_ms = arrivalTime_ms + sleepDuration_ms;

    // USLOSS_Console("waketime (ms) %d = arrival time (ms) = %d, sleep duration (ms)= %d\n",wakeTime, arrivalTime, sleepDuration);

    int mboxId = MboxCreate(1,0);
    createPCB_Clock(idx, pid, wakeTime_ms, mboxId);
    PCB_Clock * newPCB_Clock = &PROC_table_clock[idx];

    // USLOSS_Console("LINE %d\n",__LINE__);

    // Mutex for the global array of PCB
    int sendVRetVal = MboxSend(CLOCK_DAEMON_MBOX_ID, NULL, 0);

    insertClockWaitQueue(newPCB_Clock);

    int recvRetVal = MboxRecv(CLOCK_DAEMON_MBOX_ID, NULL, 0);

    // block this process so it goes to sleep
    int recVretVal = MboxRecv(mboxId, NULL, 0);

    // NOTE: unblocked after being woken up, sleep done here

    // NOTE: cleanup done in remove function
        // destroyPCB_Clock(idx);
        // MboxRelease(mboxId);

    return 0;
}

int kernSleepWrapper(USLOSS_Sysargs * args) {
    int sleepTimeSeconds = args->arg1;

    int retVal = kernSleep(sleepTimeSeconds);

    args->arg4 = retVal;
}

int  kernTermWrite(char *buffer, int bufferSize, int unitID,
                           int *numCharsRead) {
    return 0;
}

// int  kernDiskRead (void *diskBuffer, int unit, int track, int first, 
//                            int sectors, int *status) {
//     return 0;
// }

// int  kernDiskWrite(void *diskBuffer, int unit, int track, int first,
//                            int sectors, int *status) {
//     return 0;
// }
// int  kernDiskSize (int unit, int *sector, int *track, int *disk) {
//     return 0;
// }

void phase4_init(void) {
    // set up global tick counter
    // set up 7 mboxes for 7 daemons
    // clear shadow PCB

    // NOTE: FOLLOW USYSCALL.H !!
    systemCallVec[SYS_SLEEP] = kernSleepWrapper;
    systemCallVec[SYS_TERMREAD] = kernTermReadWrapper;

    // mutex for the clock device, probably not necessary
    CLOCK_DAEMON_MBOX_ID = MboxCreate(1,0);
    TERM0_DAEMON_MBOX_ID = MboxCreate(1,0);
    TERM1_DAEMON_MBOX_ID = MboxCreate(1,0);
    TERM2_DAEMON_MBOX_ID = MboxCreate(1,0);
    TERM3_DAEMON_MBOX_ID = MboxCreate(1,0);
    DISK0_DAEMON_MBOX_ID = MboxCreate(1,0);
    DISK1_DAEMON_MBOX_ID = MboxCreate(1,0);

    CLOCK_WAITQUEUE_HEAD = NULL;

    // TODO: enable Xmit and RecV interrupt bits for all 4 terminal devices
}