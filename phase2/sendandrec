// Conditional send
int MboxCondSend(int mbox_id, void *msg_ptr, int msg_size) {


  struct MB* mb = getMb(mbox_id);
  if (msg_size != 0 && msg_ptr == NULL){
    return -1;
  }

  if (msg_size > mb->messageSizeLimit){
    // ERROR MESSAGE
    //USLOSS_Console("ERROR: Message Size it too big for mb\n");
    return -1;
  }

  if (mb->isInitialized == 0){
    return -1;
  }
  int slot = findOpenMessageSlot();
    if (slot == -1) {
        return -2;
    }

if (mb->mailSlotsAvailable<=0){
      //USLOSS_Console("returned -2");
      
      return -2;

      if (mb->isInitialized==0){


        return -3;
      }
    }
    
    struct Message* m = messageSlots[slot];

    m->isInitialized = 1;
    m->message = (char*)malloc(msg_size);  // Allocate memory and copy message
    if (m->message == NULL) {
        // Handle memory allocation failure
        return -1;
    }
    memcpy(m->message, msg_ptr, msg_size);  // Copy message contents
    m->messageSizeLimit = msg_size;
    m->nextMessage = NULL;
    m->prevMessage = NULL;





    // ADD TO PRODUCER QUEUE
    
    

    // ADD TO MAIL QUEUE
    if (mb->consumerQueueHead != NULL){
      unblockProc(mb->consumerQueueHead->PID);
    }
    addToMailQueue(mb,m);

    
    //CHECK IF SPACE IN BUFFER



    //how to unblock producer probably done in consumer
    // how to unblock consumer problay done here

    return 0;

  return 0;
} 

// Conditional receive  
int MboxCondRecv(int mbox_id, void *msg_ptr, int msg_max_size) {
  //printMB(7);
  
  struct MB * mb = getMb(mbox_id);
    struct Process* curProc = getProcess(getpid());
if (mb->isInitialized == 0){
    return -1;
  }


    if (mb->mailSlotQueueHead == NULL){
      return -2;
      if (mb->isInitialized==0){

        return -3;
      }
    }
    addToConsumerQueue(mb);

    struct Message* mesRec = mb->mailSlotQueueHead;

    curProc->message = (struct Message*)malloc(sizeof(struct Message));
    memcpy(curProc->message, mesRec, sizeof(struct Message));
    memcpy(msg_ptr, curProc->message->message,mesRec->messageSizeLimit);
    mesRec->isInitialized = 0;

    mb->consumerQueueHead = mb->consumerQueueHead->nextConsumerNode;
    mb->mailSlotQueueHead = mb->mailSlotQueueHead->nextMessage;
    mb->mailSlotsAvailable++;


    if (mb->producerQueueHead!=NULL){
        struct Process* aboutToUB = mb->producerQueueHead;
        mb->producerQueueHead = mb->producerQueueHead->nextProducerNode;
        unblockProc(aboutToUB->PID);

    }





  // add msg to message queue
  /*
  if msg queue is full, add process to producer queue. Make sure to update msg
  field in that process to msg we are trying to send.
  Once msgqueue has empty slots, remove producer queue head. Get the message associated
  with that process in its message field. Add that message to the end of the message queue
  */
  return mesRec -> messageSizeLimit;

}